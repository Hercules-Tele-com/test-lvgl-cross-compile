#include <cstdio>
#include <csignal>
#include <thread>
#include <atomic>
#include <chrono>

#include "lvgl.h"

// fbdev + LVGL tick helpers (from your platform/linux/)
#include "platform/linux/fbdev_display.h"

// UI (SquareLine-generated)
#include "ui/ui.h"
#include "ui/dashboard_ui.h"

// CAN
#include "shared/can_receiver.h"

using namespace std::chrono_literals;

static std::atomic<bool> g_running{true};

static void handle_sigint(int) {
    g_running = false;
}

int main() {
    std::signal(SIGINT, handle_sigint);
    std::signal(SIGTERM, handle_sigint);

    std::printf("=== Nissan Leaf CAN Dashboard ===\n");
#if defined(__linux__)
    std::printf("Platform: Linux (Framebuffer)\n");
#endif

    // 1) fbdev: init /dev/fb0 and register LVGL display driver (also calls lv_init)
    if (!fbdev_display_init()) {
        std::fprintf(stderr, "[fbdev] init failed; is /dev/fb0 available and permission OK?\n");
        return 1;
    }

    // 2) CAN receiver with 2 channels (non-blocking reader threads)
    CANReceiver can;
    if (!can.init()) {
        std::fprintf(stderr, "[CANReceiver] failed to init.\n");
        fbdev_display_cleanup();
        return 1;
    }
    std::puts("CAN receiver initialized");

    // 5) UI (SquareLine build + our convenience wrapper)
    ui_init();                              // generated by SquareLine (creates screens)
    DashboardUI dashboard;
    dashboard.init();                       // binds widgets
    std::puts("SquareLine UI initialized");

    std::puts("==========================> Entering main loop...");

    // 6) Main loop: pump LVGL + pull any fresh CAN state to UI
    auto last_tick = std::chrono::steady_clock::now();
    while (g_running.load(std::memory_order_relaxed)) {
        // Calculate elapsed time and update LVGL tick
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_tick).count();
        if (elapsed > 0) {
            lv_tick_inc(elapsed);
            last_tick = now;
        }

        // Poll CAN sockets and process incoming messages
        can.update();

        // Update gauges from recent CAN values (this is cheap)
        dashboard.update(can);

        // Let LVGL handle timers/animations/invalidations
        lv_timer_handler();

        // Small sleep to avoid pegging a core
        std::this_thread::sleep_for(5ms);
    }

    // 3) Shutdown
    fbdev_display_cleanup();
    return 0;
}

