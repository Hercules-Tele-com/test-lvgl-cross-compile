#include <cstdio>
#include <csignal>
#include <thread>
#include <atomic>
#include <chrono>

#include "lvgl.h"

// Platform-specific display drivers
#ifdef PLATFORM_WINDOWS
    #include "platform/windows/sdl_display.h"
#elif defined(PLATFORM_LINUX)
    #include "platform/linux/fbdev_display.h"
#endif

// UI (SquareLine-generated)
#include "ui/ui.h"
#include "ui/dashboard_ui.h"

// CAN
#include "shared/can_receiver.h"

using namespace std::chrono_literals;

static std::atomic<bool> g_running{true};

static void handle_sigint(int) {
    g_running = false;
}

int main() {
    std::signal(SIGINT, handle_sigint);
    std::signal(SIGTERM, handle_sigint);

    std::printf("=== Nissan Leaf CAN Dashboard ===\n");
#ifdef PLATFORM_WINDOWS
    std::printf("Platform: Windows (SDL2)\n");
#elif defined(PLATFORM_LINUX)
    std::printf("Platform: Linux (Framebuffer)\n");
#endif

    // 1) Initialize platform-specific display
#ifdef PLATFORM_WINDOWS
    if (!sdl_display_init()) {
        std::fprintf(stderr, "[SDL] init failed\n");
        return 1;
    }
#elif defined(PLATFORM_LINUX)
    if (!fbdev_display_init()) {
        std::fprintf(stderr, "[fbdev] init failed; is /dev/fb0 available and permission OK?\n");
        return 1;
    }
#endif

    // 2) CAN receiver (mock on Windows, SocketCAN on Linux, future: CANable Pro on Windows)
    CANReceiver can;
    if (!can.init()) {
        std::fprintf(stderr, "[CANReceiver] failed to init.\n");
#ifdef PLATFORM_WINDOWS
        sdl_display_cleanup();
#elif defined(PLATFORM_LINUX)
        fbdev_display_cleanup();
#endif
        return 1;
    }
    std::puts("CAN receiver initialized");

    // 5) UI (SquareLine build + our convenience wrapper)
    ui_init();                              // generated by SquareLine (creates screens)
    DashboardUI dashboard;
    dashboard.init();                       // binds widgets
    std::puts("SquareLine UI initialized");

    std::puts("==========================> Entering main loop...");

    // 6) Main loop: pump LVGL + pull any fresh CAN state to UI
    auto last_tick = std::chrono::steady_clock::now();
    while (g_running.load(std::memory_order_relaxed)) {
        // Calculate elapsed time and update LVGL tick
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_tick).count();
        if (elapsed > 0) {
            lv_tick_inc(elapsed);
            last_tick = now;
        }

        // Process CAN messages (from log file on Windows, SocketCAN on Linux, CANable Pro in future)
        can.update();

        // Update gauges from recent CAN values (this is cheap)
        dashboard.update(can);

#ifdef PLATFORM_WINDOWS
        // Windows: SDL handles events and presents the display
        sdl_display_update();
#elif defined(PLATFORM_LINUX)
        // Linux: Let LVGL handle timers/animations/invalidations
        lv_timer_handler();
#endif

        // Small sleep to avoid pegging a core
        std::this_thread::sleep_for(5ms);
    }

    // 3) Shutdown
#ifdef PLATFORM_WINDOWS
    sdl_display_cleanup();
#elif defined(PLATFORM_LINUX)
    fbdev_display_cleanup();
#endif
    return 0;
}

